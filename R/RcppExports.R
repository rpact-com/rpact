# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

.mvnprd <- function(a, b, bpd, eps, inf, ierc, hinc) {
    .Call(`_rpact_mvnprd`, a, b, bpd, eps, inf, ierc, hinc)
}

.mvstud <- function(ndf, a, b, bpd, d, eps, inf, ierc, hnc) {
    .Call(`_rpact_mvstud`, ndf, a, b, bpd, d, eps, inf, ierc, hnc)
}

.as251NormalCpp <- function(lower, upper, sigma, eps = 1e-06, errorControl = "strict", intervalSimpsonsRule = 0.0) {
    .Call(`_rpact_as251Normal`, lower, upper, sigma, eps, errorControl, intervalSimpsonsRule)
}

.getNegativeBinomialEstimates <- function(counts1, counts2, t1, t2) {
    .Call(`_rpact_estimate_nb`, counts1, counts2, t1, t2)
}

.getFisherCombinationSizeCpp <- function(kMax, alpha0Vec, criticalValues, tVec, cases) {
    .Call(`_rpact_getFisherCombinationSizeCpp`, kMax, alpha0Vec, criticalValues, tVec, cases)
}

.getSimulatedAlphaCpp <- function(kMax, alpha0, criticalValues, tVec, iterations) {
    .Call(`_rpact_getSimulatedAlphaCpp`, kMax, alpha0, criticalValues, tVec, iterations)
}

.getFisherCombinationCases <- function(kMax, tVec) {
    .Call(`_rpact_getFisherCombinationCasesCpp`, kMax, tVec)
}

.getDesignFisherInner <- function(kMax, alpha, tolerance, criticalValues, scale, alpha0Vec, userAlphaSpending, method) {
    .Call(`_rpact_getDesignFisherTryCpp`, kMax, alpha, tolerance, criticalValues, scale, alpha0Vec, userAlphaSpending, method)
}

.getGroupSequentialProbabilitiesCpp <- function(decisionMatrix, informationRates) {
    .Call(`_rpact_getGroupSequentialProbabilitiesCpp`, decisionMatrix, informationRates)
}

.getDesignGroupSequentialPampallonaTsiatisCpp <- function(tolerance, beta, alpha, kMax, deltaPT0, deltaPT1, informationRates, sided, bindingFutility) {
    .Call(`_rpact_getDesignGroupSequentialPampallonaTsiatisCpp`, tolerance, beta, alpha, kMax, deltaPT0, deltaPT1, informationRates, sided, bindingFutility)
}

.getDesignGroupSequentialUserDefinedAlphaSpendingCpp <- function(kMax, userAlphaSpending, sided, informationRates, bindingFutility, futilityBounds, tolerance) {
    .Call(`_rpact_getDesignGroupSequentialUserDefinedAlphaSpendingCpp`, kMax, userAlphaSpending, sided, informationRates, bindingFutility, futilityBounds, tolerance)
}

.getDesignGroupSequentialAlphaSpendingCpp <- function(kMax, alpha, gammaA, typeOfDesign, sided, informationRates, bindingFutility, futilityBounds, tolerance) {
    .Call(`_rpact_getDesignGroupSequentialAlphaSpendingCpp`, kMax, alpha, gammaA, typeOfDesign, sided, informationRates, bindingFutility, futilityBounds, tolerance)
}

.getDesignGroupSequentialDeltaWTCpp <- function(kMax, alpha, sided, informationRates, bindingFutility, futilityBounds, tolerance, deltaWT) {
    .Call(`_rpact_getDesignGroupSequentialDeltaWTCpp`, kMax, alpha, sided, informationRates, bindingFutility, futilityBounds, tolerance, deltaWT)
}

.getDesignGroupSequentialPocockCpp <- function(kMax, alpha, sided, informationRates, bindingFutility, futilityBounds, tolerance) {
    .Call(`_rpact_getDesignGroupSequentialPocockCpp`, kMax, alpha, sided, informationRates, bindingFutility, futilityBounds, tolerance)
}

.getDesignGroupSequentialOBrienAndFlemingCpp <- function(kMax, alpha, sided, informationRates, bindingFutility, futilityBounds, tolerance) {
    .Call(`_rpact_getDesignGroupSequentialOBrienAndFlemingCpp`, kMax, alpha, sided, informationRates, bindingFutility, futilityBounds, tolerance)
}

.getDesignGroupSequentialBetaSpendingCpp <- function(criticalValues, kMax, userAlphaSpending, userBetaSpending, informationRates, bindingFutility, tolerance, typeOfDesign, typeBetaSpending, gammaA, gammaB, alpha, beta, sided, betaAdjustment, twoSidedPower) {
    .Call(`_rpact_getDesignGroupSequentialBetaSpendingCpp`, criticalValues, kMax, userAlphaSpending, userBetaSpending, informationRates, bindingFutility, tolerance, typeOfDesign, typeBetaSpending, gammaA, gammaB, alpha, beta, sided, betaAdjustment, twoSidedPower)
}

.getDesignGroupSequentialUserDefinedBetaSpendingCpp <- function(criticalValues, kMax, userAlphaSpending, userBetaSpending, sided, informationRates, bindingFutility, tolerance, typeOfDesign, gammaA, alpha, betaAdjustment, twoSidedPower) {
    .Call(`_rpact_getDesignGroupSequentialUserDefinedBetaSpendingCpp`, criticalValues, kMax, userAlphaSpending, userBetaSpending, sided, informationRates, bindingFutility, tolerance, typeOfDesign, gammaA, alpha, betaAdjustment, twoSidedPower)
}

.getSimulationMeansLoopCpp <- function(alternative, kMax, maxNumberOfIterations, designNumber, informationRates, futilityBounds, alpha0Vec, criticalValues, meanRatio, thetaH0, stDev, groups, normalApproximation, plannedSubjects, directionUpper, allocationRatioPlanned, minNumberOfSubjectsPerStage, maxNumberOfSubjectsPerStage, conditionalPower, thetaH1, stDevH1, calcSubjectsFunctionType, calcSubjectsFunctionR, calcSubjectsFunctionCpp) {
    .Call(`_rpact_getSimulationMeansLoopCpp`, alternative, kMax, maxNumberOfIterations, designNumber, informationRates, futilityBounds, alpha0Vec, criticalValues, meanRatio, thetaH0, stDev, groups, normalApproximation, plannedSubjects, directionUpper, allocationRatioPlanned, minNumberOfSubjectsPerStage, maxNumberOfSubjectsPerStage, conditionalPower, thetaH1, stDevH1, calcSubjectsFunctionType, calcSubjectsFunctionR, calcSubjectsFunctionCpp)
}

.getSimulationRatesCpp <- function(kMax, informationRates, criticalValues, pi1, pi2, maxNumberOfIterations, designNumber, groups, futilityBounds, alpha0Vec, minNumberOfSubjectsPerStage, maxNumberOfSubjectsPerStage, conditionalPower, pi1H1, pi2H1, normalApproximation, plannedSubjects, directionUpper, allocationRatioPlanned, riskRatio, thetaH0, calcSubjectsFunctionType, calcSubjectsFunctionR, calcSubjectsFunctionCpp) {
    .Call(`_rpact_getSimulationRatesCpp`, kMax, informationRates, criticalValues, pi1, pi2, maxNumberOfIterations, designNumber, groups, futilityBounds, alpha0Vec, minNumberOfSubjectsPerStage, maxNumberOfSubjectsPerStage, conditionalPower, pi1H1, pi2H1, normalApproximation, plannedSubjects, directionUpper, allocationRatioPlanned, riskRatio, thetaH0, calcSubjectsFunctionType, calcSubjectsFunctionR, calcSubjectsFunctionCpp)
}

.logRankTestCpp <- function(accrualTime, survivalTime, dropoutTime, treatmentGroup, time, directionUpper, thetaH0, returnRawData) {
    .Call(`_rpact_logRankTest`, accrualTime, survivalTime, dropoutTime, treatmentGroup, time, directionUpper, thetaH0, returnRawData)
}

.getSimulationSurvivalCpp <- function(designNumber, kMax, sided, criticalValues, informationRates, conditionalPower, plannedEvents, thetaH1, minNumberOfEventsPerStage, maxNumberOfEventsPerStage, directionUpper, allocationRatioPlanned, accrualTime, treatmentGroup, thetaH0, futilityBounds, alpha0Vec, pi1Vec, pi2, eventTime, piecewiseSurvivalTime, cdfValues1, cdfValues2, lambdaVec1, lambdaVec2, phi, maxNumberOfSubjects, maxNumberOfIterations, maxNumberOfRawDatasetsPerStage, kappa, calcEventsFunctionType, calcEventsFunctionR, calcEventsFunctionCpp) {
    .Call(`_rpact_getSimulationSurvivalCpp`, designNumber, kMax, sided, criticalValues, informationRates, conditionalPower, plannedEvents, thetaH1, minNumberOfEventsPerStage, maxNumberOfEventsPerStage, directionUpper, allocationRatioPlanned, accrualTime, treatmentGroup, thetaH0, futilityBounds, alpha0Vec, pi1Vec, pi2, eventTime, piecewiseSurvivalTime, cdfValues1, cdfValues2, lambdaVec1, lambdaVec2, phi, maxNumberOfSubjects, maxNumberOfIterations, maxNumberOfRawDatasetsPerStage, kappa, calcEventsFunctionType, calcEventsFunctionR, calcEventsFunctionCpp)
}

.selectPopulationsCpp <- function(effectVector, typeOfSelection, epsilonValue = NA_real_, rValue = NA_integer_, threshold = NA_real_) {
    .Call(`_rpact_selectPopulations`, effectVector, typeOfSelection, epsilonValue, rValue, threshold)
}

.performClosedCombinationTestForSimulationEnrichmentCpp <- function(stageResults, design, indices, intersectionTest, successCriterion) {
    .Call(`_rpact_performClosedCombinationTestForSimulationEnrichment`, stageResults, design, indices, intersectionTest, successCriterion)
}

.createSelectedSubsetsCpp <- function(selectedPopulationsAtStagek) {
    .Call(`_rpact_createSelectedSubsets`, selectedPopulationsAtStagek)
}

.createSubGroupsCpp <- function(gMax) {
    .Call(`_rpact_createSubGroups`, gMax)
}

.createSubGroupsFromPopulationCpp <- function(gMax, subPopulation) {
    .Call(`_rpact_createSubGroupsFromPopulation`, gMax, subPopulation)
}

.logRankTestEnrichmentCpp <- function(gMax, survivalDataSet, time, subPopulation, stratifiedAnalysis, directionUpper = TRUE, thetaH0 = 1.0) {
    .Call(`_rpact_logRankTestEnrichment`, gMax, survivalDataSet, time, subPopulation, stratifiedAnalysis, directionUpper, thetaH0)
}

.getSimulationSurvivalEnrichmentStageEventsCpp <- function(stage, directionUpper, conditionalPower, conditionalCriticalValue, plannedEvents, allocationRatioPlanned, selectedPopulations, thetaH1, overallEffects, minNumberOfEventsPerStage, maxNumberOfEventsPerStage) {
    .Call(`_rpact_getSimulationSurvivalEnrichmentStageEvents`, stage, directionUpper, conditionalPower, conditionalCriticalValue, plannedEvents, allocationRatioPlanned, selectedPopulations, thetaH1, overallEffects, minNumberOfEventsPerStage, maxNumberOfEventsPerStage)
}

.getTreatmentsSubgroupsCpp <- function(maxNumberOfSubjects, allocationFraction, subGroups, prevalences) {
    .Call(`_rpact_getTreatmentsSubgroups`, maxNumberOfSubjects, allocationFraction, subGroups, prevalences)
}

.updateSubGroupVectorCpp <- function(k, maxNumberOfSubjects, numberOfSubjects, subGroupVector, subGroups, prevSelected) {
    .Call(`_rpact_updateSubGroupVector`, k, maxNumberOfSubjects, numberOfSubjects, subGroupVector, subGroups, prevSelected)
}

.getSimulatedStageResultsSurvivalEnrichmentSubjectsBasedCpp <- function(design, weights, subGroups, prevalences, piControls, kappa, phi, eventTime, hazardRatios, directionUpper, stratifiedAnalysis, plannedEvents, recruitmentTimes, allocationFraction, typeOfSelection, effectMeasure, adaptations, epsilonValue, rValue, threshold, minNumberOfEventsPerStage, maxNumberOfEventsPerStage, conditionalPower, thetaH1, calcEventsFunction = NULL, calcEventsFunctionIsUserDefined = FALSE, selectPopulationsFunction = NULL) {
    .Call(`_rpact_getSimulatedStageResultsSurvivalEnrichmentSubjectsBased`, design, weights, subGroups, prevalences, piControls, kappa, phi, eventTime, hazardRatios, directionUpper, stratifiedAnalysis, plannedEvents, recruitmentTimes, allocationFraction, typeOfSelection, effectMeasure, adaptations, epsilonValue, rValue, threshold, minNumberOfEventsPerStage, maxNumberOfEventsPerStage, conditionalPower, thetaH1, calcEventsFunction, calcEventsFunctionIsUserDefined, selectPopulationsFunction)
}

.performSimulationEnrichmentSurvivalLoopCpp <- function(cols, maxNumberOfIterations, design, weights, effectList, kappa, phi, eventTime, recruitmentTimes, allocationFraction, directionUpper, stratifiedAnalysis, plannedEvents, typeOfSelection, effectMeasure, adaptations, epsilonValue, rValue, threshold, minNumberOfEventsPerStage, maxNumberOfEventsPerStage, conditionalPower, thetaH1, calcEventsFunction, calcEventsFunctionIsUserDefined, selectPopulationsFunction, indices, intersectionTest, successCriterion, gMax, kMax) {
    .Call(`_rpact_performSimulationEnrichmentSurvivalLoop`, cols, maxNumberOfIterations, design, weights, effectList, kappa, phi, eventTime, recruitmentTimes, allocationFraction, directionUpper, stratifiedAnalysis, plannedEvents, typeOfSelection, effectMeasure, adaptations, epsilonValue, rValue, threshold, minNumberOfEventsPerStage, maxNumberOfEventsPerStage, conditionalPower, thetaH1, calcEventsFunction, calcEventsFunctionIsUserDefined, selectPopulationsFunction, indices, intersectionTest, successCriterion, gMax, kMax)
}

.dunnettIntegrand1IntCpp <- function(criticalValue, informationAtInterim, signedTestStatistics, frac, indicesRow) {
    .Call(`_rpact_dunnettIntegrand1Int`, criticalValue, informationAtInterim, signedTestStatistics, frac, indicesRow)
}

.dunnettIntegrand1EvaluateCpp <- function(x, criticalValue, informationAtInterim, signedTestStatistics, frac, indicesRow) {
    .Call(`_rpact_dunnettIntegrand1Evaluate`, x, criticalValue, informationAtInterim, signedTestStatistics, frac, indicesRow)
}

.dunnettIntegrand2IntCpp <- function(maxOverallTestStatistic, informationAtInterim, signedTestStatistics, frac, indicesRow, overallTestStatistics) {
    .Call(`_rpact_dunnettIntegrand2Int`, maxOverallTestStatistic, informationAtInterim, signedTestStatistics, frac, indicesRow, overallTestStatistics)
}

.dunnettIntegrand2EvaluateCpp <- function(x, maxOverallTestStatistic, informationAtInterim, signedTestStatistics, frac, indicesRow, overallTestStatistics) {
    .Call(`_rpact_dunnettIntegrand2Evaluate`, x, maxOverallTestStatistic, informationAtInterim, signedTestStatistics, frac, indicesRow, overallTestStatistics)
}

.dunnettIntegrand3IntCpp <- function(maxTestStatistic, frac, indicesRow, separatePValues) {
    .Call(`_rpact_dunnettIntegrand3Int`, maxTestStatistic, frac, indicesRow, separatePValues)
}

.dunnettIntegrand3EvaluateCpp <- function(x, maxTestStatistic, frac, indicesRow, separatePValues) {
    .Call(`_rpact_dunnettIntegrand3Evaluate`, x, maxTestStatistic, frac, indicesRow, separatePValues)
}

.performClosedConditionalDunnettTestForSimulationCpp <- function(stageResults, design, indices, criticalValuesDunnett, successCriterion) {
    .Call(`_rpact_performClosedConditionalDunnettTestForSimulation`, stageResults, design, indices, criticalValuesDunnett, successCriterion)
}

.performClosedCombinationTestForSimulationMultiArmCpp <- function(stageResults, design, indices, intersectionTest, successCriterion) {
    .Call(`_rpact_performClosedCombinationTestForSimulationMultiArm`, stageResults, design, indices, intersectionTest, successCriterion)
}

.getSimulatedStageMeansMultiArmCpp <- function(design, muVector, stDev, plannedSubjects, typeOfSelection, effectMeasure, adaptations, epsilonValue, rValue, threshold, allocationRatioPlanned, minNumberOfSubjectsPerStage, maxNumberOfSubjectsPerStage, conditionalPower, thetaH1, stDevH1, calcSubjectsFunction, calcSubjectsFunctionIsUserDefined, selectArmsFunction) {
    .Call(`_rpact_getSimulatedStageMeansMultiArmCpp`, design, muVector, stDev, plannedSubjects, typeOfSelection, effectMeasure, adaptations, epsilonValue, rValue, threshold, allocationRatioPlanned, minNumberOfSubjectsPerStage, maxNumberOfSubjectsPerStage, conditionalPower, thetaH1, stDevH1, calcSubjectsFunction, calcSubjectsFunctionIsUserDefined, selectArmsFunction)
}

.getSimulationMultiArmMeansInnerLoopCpp <- function(iterations, simulatedFutilityStopping, simulatedConditionalPower, i, j, gMax, kMax, cols, index, simulatedSubjectsPerStage, simulatedRejections, simulatedSelections, simulatedNumberOfActiveArms, simulatedSuccessStopping, muMaxVector, effectMatrix, dataIterationNumber, dataStageNumber, dataArmNumber, dataAlternative, dataEffect, dataSubjectsControlArm, dataSubjectsActiveArm, dataNumberOfSubjects, dataNumberOfCumulatedSubjects, dataRejectPerStage, dataTestStatistics, dataSuccessStop, dataFutilityStop, dataConditionalCriticalValue, dataConditionalPowerAchieved, dataEffectEstimate, dataPValuesSeparate, simulatedRejectAtLeastOne, design, indices, criticalValuesDunnett, intersectionTest, successCriterion, stDev, plannedSubjects, typeOfSelection, effectMeasure, adaptations, epsilonValue, rValue, threshold, allocationRatioPlanned, minNumberOfSubjectsPerStage, maxNumberOfSubjectsPerStage, conditionalPower, thetaH1, stDevH1, calcSubjectsFunction, calcSubjectsFunctionIsUserDefined, selectArmsFunction, stageResults) {
    .Call(`_rpact_simulationMultiArmMeansInnerLoopCpp`, iterations, simulatedFutilityStopping, simulatedConditionalPower, i, j, gMax, kMax, cols, index, simulatedSubjectsPerStage, simulatedRejections, simulatedSelections, simulatedNumberOfActiveArms, simulatedSuccessStopping, muMaxVector, effectMatrix, dataIterationNumber, dataStageNumber, dataArmNumber, dataAlternative, dataEffect, dataSubjectsControlArm, dataSubjectsActiveArm, dataNumberOfSubjects, dataNumberOfCumulatedSubjects, dataRejectPerStage, dataTestStatistics, dataSuccessStop, dataFutilityStop, dataConditionalCriticalValue, dataConditionalPowerAchieved, dataEffectEstimate, dataPValuesSeparate, simulatedRejectAtLeastOne, design, indices, criticalValuesDunnett, intersectionTest, successCriterion, stDev, plannedSubjects, typeOfSelection, effectMeasure, adaptations, epsilonValue, rValue, threshold, allocationRatioPlanned, minNumberOfSubjectsPerStage, maxNumberOfSubjectsPerStage, conditionalPower, thetaH1, stDevH1, calcSubjectsFunction, calcSubjectsFunctionIsUserDefined, selectArmsFunction, stageResults)
}

.hmmCpp <- function(gMax, k, i, cols, kMax, simulatedRejections, closedTest, rejectedArmsBefore, cheat) {
    .Call(`_rpact_hmm`, gMax, k, i, cols, kMax, simulatedRejections, closedTest, rejectedArmsBefore, cheat)
}

.firstCpp <- function(gMax, k, i, cols, kMax, simulatedSelections, closedTest) {
    .Call(`_rpact_first`, gMax, k, i, cols, kMax, simulatedSelections, closedTest)
}

.funnyBoolCpp <- function(k, kMax, closedTest) {
    .Call(`_rpact_funnyBool`, k, kMax, closedTest)
}

.lastSectionCpp <- function(simulatedSubjectsPerStage, iterations, i, gMax, kMax, cols, simulatedRejections, simulatedSuccessStopping, simulatedFutilityStopping, maxNumberOfIterations, expectedNumberOfSubjects) {
    .Call(`_rpact_lastSection`, simulatedSubjectsPerStage, iterations, i, gMax, kMax, cols, simulatedRejections, simulatedSuccessStopping, simulatedFutilityStopping, maxNumberOfIterations, expectedNumberOfSubjects)
}

.findObservationTimeCpp <- function(accrualTime, survivalTime, dropoutTime, requiredStageEvents) {
    .Call(`_rpact_findObservationTime`, accrualTime, survivalTime, dropoutTime, requiredStageEvents)
}

getOneMinusQNorm <- function(p, mean = 0, sd = 1, lowerTail = 1, logP = 0, epsilon = 1.0e-100) {
    .Call(`_rpact_getOneMinusQNorm`, p, mean, sd, lowerTail, logP, epsilon)
}

.orderCpp <- function(x) {
    .Call(`_rpact_order`, x)
}

zeroin <- function(f, lower, upper, tolerance, maxIter) {
    .Call(`_rpact_zeroin`, f, lower, upper, tolerance, maxIter)
}

getCipheredValue <- function(x) {
    .Call(`_rpact_getCipheredValue`, x)
}

.getFraction <- function(x, epsilon = 1.0e-6, maxNumberOfSearchSteps = 30L) {
    .Call(`_rpact_getFraction`, x, epsilon, maxNumberOfSearchSteps)
}

.getFractions <- function(x, epsilon = 1.0e-6, maxNumberOfSearchSteps = 30L) {
    .Call(`_rpact_getFractions`, x, epsilon, maxNumberOfSearchSteps)
}

.getMultivarNormalDistributionCpp <- function(upper, sigma) {
    .Call(`_rpact_getMultivarNormalDistribution`, upper, sigma)
}

.tcrossprodCpp <- function(x) {
    .Call(`_rpact_tcrossprod`, x)
}

